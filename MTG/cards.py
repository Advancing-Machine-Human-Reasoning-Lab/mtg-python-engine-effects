import sys
import pickle
import math
import re
from collections import namedtuple

from MTG.parsedcards import *
from MTG.exceptions import *
from MTG import abilities
from MTG import triggers
from MTG import mana
from MTG import helper_funcs
from MTG import permanent


SETPREFIX = ['M15', 'sm_set']
name_to_id_dict = {}
id_to_name_dict = {}

# compile all the dictionaries from different parsed sets
for pre in SETPREFIX:
    try:
        with open('data/%s_name_to_id_dict.pkl' % pre, 'rb') as f:
            name_to_id_dict.update(pickle.load(f))
    except:
        print("%s name_to_id_dict not found\n" % pre)

    try:
        with open('data/%s_id_to_name_dict.pkl' % pre, 'rb') as f:
            id_to_name_dict.update(pickle.load(f))
    except:
        print("%s id_to_name_dict not found\n" % pre)


def id_to_name(ID):
    return id_to_name_dict.get(ID, None)


def name_to_id(name):
    return name_to_id_dict.get(name, None)


def str_to_class(str):
    return getattr(sys.modules[__name__], str)


def card_from_name(name, get_instance=True):
    ID = name_to_id(name)
    if ID is not None:
        if get_instance:  # gets instance of class
            # default card class generated by parse_cards.py
            return str_to_class(ID)()
        else:
            return str_to_class(ID)
    else:
        raise CardNotImplementedException


def read_deck(filename):
    """File format:
    NUM CARDNAME

    e.g.
    10 Plains
    10 Oreskos Swiftclaw

    """
    with open(filename, 'r') as f:
        file = f.read().split("\n")
        deck = []
        for line in file:
            try:
                i = line.index(" ")
                num = int(line[:i])
                for j in range(num):  # add NUM copies of CARDNAME
                    card = card_from_name(line[i + 1:])
                    if card:
                        deck.append(card)
                        # print(deck[-1].name)
                    else:
                        pass
                        # print("card {} does not exist\n".format(line[i+1:]))
            except:
                raise DecklistFormatException

    return deck


def add_activated_ability(cardname, cost, effect, target_criterias=None, prompts=None):
    if not name_to_id(cardname):
        return
    card = card_from_name(cardname, get_instance=False)
    is_mana_ability = 'mana.add' in effect

    _costs = cost.split(', ')
    costs = []

    if 'T' in _costs:
        costs.append("self.tap() and not self.is_summoning_sick")

    for itm in _costs:
        if mana.mana_pattern.match(itm):
            costs.append("self.controller.pay('%s')" % itm)

        if re.match('[pP]ay [\dX]+ life', itm):
            costs.append("self.controller.pay(life=%s)" %
                         re.search('[\dX]+', itm).group(0))

    # elif other costs

    costs = " and ".join(costs)

    if not card.activated_abilities:  # hasn't been initiated yet
        card.activated_abilities = []

    if target_criterias:
        target_criterias = helper_funcs.parse_targets(target_criterias)

    # same signature as abilities.ActivatedAbilities.init
    card.activated_abilities.append((costs, effect, target_criterias, prompts, is_mana_ability))


def add_targets(cardname, criterias=[lambda self, p: True], prompts=None):
    if not name_to_id(cardname):
        return
    card = card_from_name(cardname, get_instance=False)
    if not prompts:
        prompts = ["Choose a target\n"] * len(criterias)

    criterias = helper_funcs.parse_targets(criterias)

    card.target_criterias = criterias
    card.target_prompts = prompts


def add_play_func_with_targets(cardname, outcome=lambda self, t, l: True):
    if not name_to_id(cardname):
        return
    card = card_from_name(cardname, get_instance=False)

    def play_func(self):
        legality = [c(self, t) for c, t in zip(self.target_criterias, self.targets_chosen)]
        if any(legality):
            outcome(self, self.targets_chosen, legality)
            if not self.is_aura:
                self.controller.graveyard.add(self)
        else:
            self.controller.graveyard.add(self)

    card.play_func = play_func


def add_play_func_no_target(cardname, outcome=lambda self: True):
    if not name_to_id(cardname):
        return
    card = card_from_name(cardname, get_instance=False)

    card.play_func = outcome


def add_aura_effect(cardname, effects, target_criterias=['creature']):
    add_targets(cardname, target_criterias)
    add_play_func_with_targets(cardname, lambda self, targets, l: permanent.make_aura(self, targets[0]))

    # add aura enchant effects
    card = card_from_name(cardname, get_instance=False)
    card.continuous_effects = effects

def add_trigger(cardname, condition, effect, requirements=lambda self: True,
                target_criterias=None, target_prompts=None):
    """
    Each effect is a function of the form
        lambda self: do_something

    It will be passed into the stack as
        play.Play(lambda: effect(self))

    where self is the source of the trigger (the permanent)
    """
    if not name_to_id(cardname):
        return
    card = card_from_name(cardname, get_instance=False)

    if not requirements:
        requirements = lambda self: True

    # make it a variable specific to card rather than a card.Card class var
    # normally, trigger_listeners is defined in card.Card,
    # and our parsed card classes just inherit that
    if card.triggers == {}:
        card.triggers = {}

    if condition not in card.triggers:
        card.triggers[condition] = []


    if target_criterias:
        target_criterias = helper_funcs.parse_targets(target_criterias)
        if not target_prompts:
            target_prompts = ["Choose a target\n"] * len(target_criterias)

    # each element in the dict is a list of triggers, since there could be multiple abilities
    # that trigger from the same effect, e.g. tap AND draw a card on etb
    # each of them will go into a separate play.Play object and be put onto the stack
    card.triggers[condition].append((effect, requirements,
                                     target_criterias, target_prompts))




def indentation_lv(s):
    """ Must be tab indented """
    lv = 0
    for i in s:
        if i == '\t':
            lv += 1
        else:
            break
    return lv



def parse_card_from_lines(lines, log=None):
    """ Lines are formatted according to 'data/cards.txt'
    
    Each set of lines correspond to all abilities/effects of a single card
    """
    stage = 'new card'
    name = ''

    effects = []
    abilities = []
    targets = []
    target_prompts = []
    _triggers = []  # _ since we import MTG.triggers

    aura_targets = []
    aura_effects = []

    prev_ind_lv = 0
    prev_line = ''
    lines.append('')


    # we actually only parse a line until we're certain there's nothing following it
    # so everytime we read a new line,
    #   we parse the last line and store our new line in prev_line
    for line in lines:
        ind_lv = indentation_lv(line)
        line = line.lstrip()

        if line and line[0] == '#':
            continue

        if not prev_line:
            prev_line = line
            prev_ind_lv = ind_lv
            continue

        if ind_lv > 1 + prev_ind_lv:  # line continuation
            prev_line += ' ' + line
            continue  # wait to parse until we've read in
                      # the entire multi-line statement


        # ok now we're ready to parse the previous line
        # swap the two vars so we're processing line = prev_line
        line, prev_line = prev_line, line
        ind_lv, prev_ind_lv = prev_ind_lv, ind_lv

        if stage == 'new card':  # read in card name
            name = line
            stage = 'effects'
            continue

        if ind_lv == 1:
            if line == 'Abilities:':
                stage = 'abilities'
                continue

            elif line == 'Targets:':
                stage = 'targets'
                continue

            elif line == 'Triggers:':
                stage = 'triggers'
                continue

            elif line == 'Aura:':
                stage = 'aura'
                continue

            else:
                stage = 'effects'


        if stage == 'effects':  # read in card effects
            effects.append(line)

        elif stage == 'abilities':
            # split ability by 'cost: effect'
            index = line.index(":")
            abilities.append((line[:index], line[index+2:]))

        elif stage == 'targets':
            if ind_lv == 2:
                # shortcut targets, like 'creature', are surrounded in quotes and will be kept intact
                # otherwise, we should prefix it with the correct lambda signature for add_target()
                if line[0] != "'":
                    line = 'lambda self, p: ' + line
                targets.append(line)

            elif ind_lv == 4:  # previous line should be 'Prompt:'
                target_prompts.append(bytes(line, "utf-8").decode("unicode_escape"))  # remove quotes, convert to string

        elif stage == 'triggers':
            if ind_lv == 2:  # new trigger condition
                _triggers.append([line, []])
            elif ind_lv == 3:
                if line == 'If:':
                    pass
                else:
                    _triggers[-1][-1].append(line)  # trigger effect
            elif ind_lv == 4:  # previous line should have been 'If:'
                _triggers[-1].append(line)  # optional trigger requirements

        elif stage == 'aura':
            if ind_lv == 2:
                if line == 'Targets:':
                    pass
                else:
                    aura_effects.append(line)

            if ind_lv == 3:   # prev line == 'Targets:':
                if line[0] != "'":
                    line = 'lambda self, p: ' + line
                aura_targets.append(line)



    # print(name, targets, abilities, _triggers, effects)
    str_to_exe = ""

    if abilities:
        for cost, effect in abilities:
            str_to_exe += "add_activated_ability(%r, %r, %r)\n" % (name, cost, effect)


    if targets:
        targets = '[' + ', '.join(targets) + ']'
        str_to_exe += "add_targets(%r, %s, prompts=%r)\n" % (
                    name, targets, target_prompts)


    # we need to use awkward '[' + ', '.join(..) + ']' for two reasons:
    #   - converting list to str for exec()
    #   - removing the quotation marks from the inner elements of the list,
    #     turning them from strings into statements

    if _triggers:
        for trig in _triggers:
            if len(trig) == 2:
                trig[1] = '[' + ', '.join(trig[1]) + ']'
                str_to_exe += "add_trigger(%r, triggers.triggerConditions[%r], %r)\n" % (
                                    name, trig[0], trig[1])

            else:  # optional trigger requirements
                trig[1] = '[' + ', '.join(trig[1]) + ']'
                trig[2] =  "lambda self: " + trig[2]
                str_to_exe += "add_trigger(%r, triggers.triggerConditions[%r], %r, %s)\n" % (
                                    name, trig[0], trig[1], trig[2])


    if effects:
        if not targets:
            effects = 'lambda self: [' + ', '.join(effects) + ']'
            str_to_exe += "add_play_func_no_target(%r, %s)\n" % (name, effects)

        else:
            effects = ("lambda self, targets, is_legal_target: ["
                      + ', '.join(effects) + ']')
            str_to_exe += "add_play_func_with_targets(%r, %s)\n" % (
                                name, effects)

    if aura_effects:
        aura_effects = '[' + ', '.join(aura_effects) + ']'
        aura_targets = '[' + ', '.join(aura_targets) + ']'
        str_to_exe += "add_aura_effect(%r, %r, %s)\n" % (name, aura_effects, aura_targets)

    if log:
        log.write(str_to_exe + "\n")

    exec(str_to_exe)


def set_up_cards(FILES=['data/cards.txt']):
    """
    Read in cards information from data/cards.txt

    Logs in set_up_cards.log

    """

    f_log = open('set_up_cards.log', 'w')

    for name in FILES:
        f = open(name, 'r')
        lines = []  # buffer

        for line in f:
            line = line.rstrip()
            if not line:
                continue

            if line[:3] == '###':  # end of a card
                parse_card_from_lines(lines, f_log)
                lines = []
            else:  # wait to parse cards until we've read in all information about a card
                lines.append(line)


    add_activated_ability("Grindclock", "T",
            "self.targets_chosen[0].mill(self.card.num_counters('Charge'))",
            ['player'])

    add_trigger("Kinsbaile Skirmisher", triggers.triggerConditions['onEtB'],
            '[self.targets_chosen[0].add_effect("modifyPT", (1, 1), self, self.game.eot_time)]',
            requirements=None,
            target_criterias=['creature'])

    # add_aura_effect("Battle Mastery", '[self.add_ability("Double Strike")]')