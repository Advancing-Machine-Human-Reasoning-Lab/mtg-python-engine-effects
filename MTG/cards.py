import sys, pickle

from MTG import card
from MTG import cardtype
from MTG import abilities
from MTG import player
from MTG import zone
from MTG.parsedcards import *
# from cards.parsed_cards import *
# from cards.M15_cards import *

SETPREFIX = ['M15', 'test_set']
name_to_id_dict = {}
id_to_name_dict = {}

for pre in SETPREFIX:
    try:
        with open('cards/%s_name_to_id_dict.pkl' % pre, 'rb') as f:
            name_to_id_dict.update(pickle.load(f))
    except:
        print("%s name_to_id_dict not found\n" % pre)

    try:
        with open('cards/%s_id_to_name_dict.pkl' % pre, 'rb') as f:
            id_to_name_dict.update(pickle.load(f))
    except:
        print("%s id_to_name_dict not found\n" % pre)


def id_to_name(ID):
    return id_to_name_dict.get(ID, None)

def name_to_id(name):
    return name_to_id_dict.get(name, None)

def str_to_class(str):
    return getattr(sys.modules[__name__], str)

def card_from_name(name, get_instance=True):
    ID = name_to_id(name)
    if ID is not None:
        if get_instance:  # gets instance of class
            return str_to_class(ID)()  # default card class generated by parse_cards.py
        else:
            return str_to_class(ID)
    else:
        return None

def read_deck(filename):
    """File format:
    NUM CARDNAME

    e.g.
    10 Plains
    10 Oreskos Swiftclaw

    """
    with open(filename, 'r') as f:
        file = f.read().split("\n")
        deck = []
        for line in file:
            try:
                i = line.index(" ")
                num = int(line[:i])
                for j in range(num):  # add NUM copies of CARDNAME
                    card = card_from_name(line[i+1:])
                    if card:
                        deck.append(card)
                        # print(deck[-1].name())
                    else:
                        pass
                        # print("card {} does not exist\n".format(line[i+1:]))
            except:
                raise DecklistFormatError()
    
    return deck


def add_activated_ability(cardname, cost, effect, is_mana_ability=False):
    if not name_to_id(cardname):
        return
    card = card_from_name(cardname, get_instance=False)

    _costs = cost.split(', ')
    costs = ""
    costs_validation = "True"
    if 'T' in _costs:
        costs += "self.tap();"
        costs_validation += " and not self.status.tapped"
    # elif MANA


    card.activated_abilities.append((costs, effect, is_mana_ability))

    card._activated_abilities_costs.append(lambda self: exec(costs))
    card._activated_abilities_costs_validation.append(lambda self: eval(costs_validation))
    card._activated_abilities_effects.append(lambda self: exec(effect))




def add_targets(cardname, criterias=[lambda p: True], prompts=["Choose a target\n"]):
    if not name_to_id(cardname):
        return
    card = card_from_name(cardname, get_instance=False)

    card.target_criterias = criterias
    card.target_prompts = prompts


def make_play_func_deal_damage_to_single_target(cardname, dmg):
    if not name_to_id(cardname):
        return
    card = card_from_name(cardname, get_instance=False)

    def play_func(self):
        if self.targets_chosen and self.target_criterias[0](self.targets_chosen[0]):
            self.targets_chosen[0].take_damage(self, dmg)
        self.controller.graveyard.add(self)

    card.play_func = play_func


add_activated_ability("Plains", 'T', 'self.controller.mana.add(mana.Mana.WHITE, 1)', True)
add_activated_ability("Island", 'T', 'self.controller.mana.add(mana.Mana.BLUE, 1)', True)
add_activated_ability("Swamp", 'T', 'self.controller.mana.add(mana.Mana.BLACK, 1)', True)
add_activated_ability("Mountain", 'T', 'self.controller.mana.add(mana.Mana.RED, 1)', True)
add_activated_ability("Forest", 'T', 'self.controller.mana.add(mana.Mana.GREEN, 1)', True)
# add_activated_ability("Wastes", 'T', 'self.controller.mana.add(mana.Mana.COLORLESS, 1)', True)

# add_targets("Lightning Bolt", [lambda p: p.__class__.__name__ == 'Player' 
#                             or p.is_creature() and p.zone == zone.ZoneType.BATTLEFIELD])
# make_play_func_deal_damage_to_single_target("Lightning Bolt", 3)

add_targets("Lightning Strike", [lambda p: p.__class__.__name__ == 'Player' 
                            or p.is_creature() and p.zone == zone.ZoneType.BATTLEFIELD])
make_play_func_deal_damage_to_single_target("Lightning Strike", 3)